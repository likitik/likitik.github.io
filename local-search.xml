<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初识Hbase</title>
    <link href="/2020/07/05/%E5%88%9D%E8%AF%86Hbase/"/>
    <url>/2020/07/05/%E5%88%9D%E8%AF%86Hbase/</url>
    
    <content type="html"><![CDATA[<h1 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h1><p><a href="https://mp.weixin.qq.com/s/9Y4HXb4UG8Fxu2F0YXBuMQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9Y4HXb4UG8Fxu2F0YXBuMQ</a></p><p>Hbase：<br>完全分布式，数据分片，故障自恢复<br>底层HDFS（存储计算分离）<br>扩展好，内置容错恢复和数据冗余</p><h3 id="Hbase-vs-Hive"><a href="#Hbase-vs-Hive" class="headerlink" title="Hbase vs Hive"></a>Hbase vs Hive</h3><p>hbase：hadoop database，基于hadoop的分布式nosql数据库，主要适用于海量（PB级）明细数据的随机实时查询，如交易明细，轨迹行为。</p><p>hbase是面向列的KV数据库，架构上由client，Zookeeper，HMaster，HRegion组成。</p><ul><li>ZK 集群是负责转发 Client 的请求和提供心跳机制，会让 HRegion Server 和 HRegion 注册进来，同时保存着 Rowkey 和 Region 的映射关系。</li><li>HMaster 中可以有多个待命，只有一个在活跃。</li></ul><p>Region Server即机器节点，包含多个Region，一个Region包含多个CF（Column Family）</p><p>一个Region Server中有一张HLOG，多张Table，一张Table可以有多个Region，一个Region有多个Store，一个CF是存在一个Store中的（Mem Store 、Store File）。</p><p><img src="https://cdn.jsdelivr.net/gh/likitik/helloworld@master/img/ea_hbase.png" srcset="/img/loading.gif" alt="hbase"></p><p>KEY是以Row key + CF + Column + TimeStamp 组成。</p><p>读取和写入都是先找到对应的Region Server，再找到对应的Region</p><p>先访问MemStore，再考虑磁盘的Storefile。（类似LSM）</p><p><a href="https://juejin.im/post/5c31cf486fb9a04a102f6f89" target="_blank" rel="noopener">https://juejin.im/post/5c31cf486fb9a04a102f6f89</a></p><p>通俗的说，hbase的作用类似于数据库，传统数据库管理的是集中的本地数据文件，而<strong>hbase基于hdfs实现对分布式数据文件的管理，比如增删改查</strong>。也就是说，hbase<strong>只是利用hadoop的hdfs帮助其管理数据的持久化文件（HFile）</strong>，<strong>它跟MapReduce没任何关系。</strong></p><p><strong>hbase的优势在于实时计算</strong>，所有实时数据都直接存入hbase中，客户端通过API直接访问hbase，实现实时计算。由于它使用的是nosql，或者说是列式结构，从而提高了查找性能，使其能运用于大数据场景，这是它跟MapReduce的区别。</p><p><strong>hadoop是hive和hbase的基础</strong>，hive依赖hadoop，而hbase仅依赖hadoop的hdfs模块。</p><p>hive适用于<strong>离线数据的分析</strong>，操作的是通用格式的（如通用的日志文件）、被hadoop管理的数据文件，它支持类sql，比编写MapReduce的java代码来的更加方便，它的定位是数据仓库，存储和分析历史数据。</p><p>hbase适用于<strong>实时计算</strong>，采用列式结构的nosql，操作的是自己生成的特殊格式的HFile、被hadoop管理的数据文件，它的定位是数据库，或者叫DBMS。</p><p>hive可以直接操作hdfs中的文件作为它的表的数据，也可以使用hbase数据库作为它的表。</p><p><a href="https://blog.csdn.net/JiaoZi00_/article/details/80262244" target="_blank" rel="noopener">https://blog.csdn.net/JiaoZi00_/article/details/80262244</a></p><h1 id="InnoDB-Buffer-Pool"><a href="#InnoDB-Buffer-Pool" class="headerlink" title="InnoDB Buffer Pool"></a>InnoDB Buffer Pool</h1><p><a href="https://zhuanlan.zhihu.com/p/65811829" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65811829</a></p><h2 id="HBase场景"><a href="#HBase场景" class="headerlink" title="HBase场景"></a>HBase场景</h2><ol><li>通过ETL工具将数据源抽取到HDFS存储；</li><li>通过Hive清洗、处理和计算原始数据；</li><li>HIve清洗处理后的结果，如果是面向海量数据随机查询场景的可存入Hbase</li><li>数据应用从HBase查询数据；</li></ol><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/305680/1590997565954-81b8860c-42c5-45df-bf2a-a9c2bd470766.png#align=left&display=inline&height=270&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=1954&size=280626&status=done&style=none&width=977" srcset="/img/loading.gif" alt="image.png"><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/305680/1590992678139-ffb730ad-a80f-42bf-87d5-95413ae0a059.png#align=left&display=inline&height=804&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1608&originWidth=3004&size=1999601&status=done&style=none&width=1502" srcset="/img/loading.gif" alt="image.png"><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/305680/1590992713244-fbd5d447-0ca9-4319-b3e0-7590ecfc7f60.png#align=left&display=inline&height=826&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1652&originWidth=3006&size=2009880&status=done&style=none&width=1503" srcset="/img/loading.gif" alt="image.png"></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/305680/1590992731407-ee295d1c-a53f-4e86-9507-18463cab9a4a.png#align=left&display=inline&height=849&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1698&originWidth=2850&size=2093493&status=done&style=none&width=1425" srcset="/img/loading.gif" alt="image.png"></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/305680/1590992805830-2c8194e8-9f02-48b6-8bff-f3a0aa9c0b05.png#align=left&display=inline&height=822&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1644&originWidth=3014&size=1670759&status=done&style=none&width=1507" srcset="/img/loading.gif" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>”大数据“</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java设计规则引擎</title>
    <link href="/2020/07/05/java%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
    <url>/2020/07/05/java%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>用java设计一个规则引擎，要求首先抽象独立的规则，实现可插拔自定义的有序规则集</p><p>例如：结果有效的条件为满足顺序满足规则1，2，3</p><p>设计思路：将枚举与匿名内部类一起使用</p></blockquote><p>规则接口</p><pre><code class="hljs jade">public interface Rule &#123;    public Object apply(Object object);&#125;</code></pre><p>具体规则</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  ConcreteRule &#123;    RULE_ONE(<span class="hljs-keyword">new</span> Rule()&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Object object)</span> </span>&#123;            System.out.println(<span class="hljs-string">"RULE ONE"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;),    RULE_TWO(<span class="hljs-keyword">new</span> Rule() &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Object object)</span> </span>&#123;            System.out.println(<span class="hljs-string">"RULE TWO"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;),    RULE_THREE(<span class="hljs-keyword">new</span> Rule() &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Object object)</span> </span>&#123;            System.out.println(<span class="hljs-string">"RULE THREE"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;)    ;    <span class="hljs-keyword">private</span> Rule rule;    ConcreteRule(Rule rule) &#123;        <span class="hljs-keyword">this</span>.rule = rule;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Object object)</span></span>&#123;        <span class="hljs-keyword">return</span> rule.apply(object);    &#125;&#125;</code></pre><p>规则集</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuleSet</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;ConcreteRule&gt; rules;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RuleSet</span><span class="hljs-params">()</span></span>&#123;        rules = <span class="hljs-keyword">new</span> ArrayList&lt;ConcreteRule&gt;();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ConcreteRule rule)</span></span>&#123;        rules.add(rule);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Object object)</span></span>&#123;        <span class="hljs-keyword">for</span> (ConcreteRule rule : rules)&#123;            rule.apply(object);        &#125;        System.out.println(<span class="hljs-string">"rules apply over!"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>规则工厂</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuleSets</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RuleSets</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RuleSet <span class="hljs-title">isXXX</span><span class="hljs-params">()</span></span>&#123;        RuleSet ruleSet = <span class="hljs-keyword">new</span> RuleSet();        ruleSet.add(ConcreteRule.RULE_ONE);        ruleSet.add(ConcreteRule.RULE_TWO);        ruleSet.add(ConcreteRule.RULE_THREE);        <span class="hljs-keyword">return</span> ruleSet;    &#125;&#125;</code></pre><p>Main函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Object a = <span class="hljs-keyword">new</span> Object();  RuleSet ruleSet = RuleSets.isXXX();  ruleSet.apply(a);&#125;</code></pre><ul><li>TODO：可以考虑lambda表达式简化构造</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>”java设计模式“</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Epoll</title>
    <link href="/2020/07/05/Epoll/"/>
    <url>/2020/07/05/Epoll/</url>
    
    <content type="html"><![CDATA[<h4 id="Select-Epoll"><a href="#Select-Epoll" class="headerlink" title="Select,Epoll"></a>Select,Epoll</h4><ul><li><p>一次ＩＯ访问，需要先将数据拷贝进内核缓冲区，再拷贝到应用程序地址空间。</p></li><li><p>阻塞</p></li><li><ul><li>进程发起read请求，等待状态下进程主动阻塞</li></ul></li><li><p>非阻塞</p></li><li><ul><li>进程不断的主动询问内核，返回ｅｒｒｏｒ</li></ul></li><li><p>I/O多路复用</p></li><li><ul><li>单个process就可以同时处理多个网络连接的IO，select，poll，epoll这个function会不断的轮询所负责的所有socket，，当某个socket有数据到达了，就通知用户进程。</li></ul></li><li><p>如何知道接收了数据：</p></li><li><ul><li>网卡把数据写入内存后，向cpu发出一个中断信号，操作系统就知道有新数据来了</li></ul></li><li><p>阻塞为什么不占用cpu资源</p></li><li><ul><li>进程阻塞，进入等待队列（从cpu轮询的工作队列中移出），socket创建一个由文件系统管理的对象，这个socket对象包含了发送接收缓冲区以及等待队列的成员，当网卡通知cpu有数据到达，cpu执行中断程序，把网络数据写入socket接收缓冲区，再唤醒等待队列的进程</li></ul></li><li><p>如何同时监视多个socket的数据？</p></li><li><p>select：</p></li><li><ul><li><p>如果程序A同时监视多个socket，那么就把该进程分别加入这多个socket的等待队列中，这样任何一个socket收到数据，都会唤醒进程，但之后程序需要遍历socket列表，才能得到具体是哪个socket就绪了。</p></li><li><p>缺点：</p></li><li><ul><li>每次调用需要把进程加入所有监视的socket等待队列中，每次唤醒也需要遍历寻找和移除，因此每次都要将整个FDS列表传给内核，开销很大。</li><li>最大监视数1024</li></ul></li></ul></li><li><p>epoll：</p></li><li><ul><li><p>功能分离，用epoll_ctl维护等待队列，用epoll_wait阻塞进程</p></li><li><p>epoll_create:内核创建一个event poll对象，也是文件系统一员，有自己的等待队列</p></li><li><ul><li>就绪列表rdlist，保存所有就绪的socket，避免遍历（双向链表实现）</li><li>等待队列，连进程</li><li>索引结构，保存socket，用红黑树</li></ul></li><li><p>监视过程变为把eventpoll对象添加到每个socket的等待队列中，收到数据后，中断程序要做的是操作eventpoll对象，给rdlist添加socket引用，所以当epoll_wait的时候，如果rdlist不为空直接返回</p></li></ul></li><li><p>水平触发与边缘触发</p></li><li><ul><li>水平触发：每次文件描述符就绪后，一遍一次IO没有执行完，下次epoll_wait时还是就绪态，还可以继续执行。只要缓冲区不空就可以读，不满就可以写，如果没有一次性读写完，下次还会提示就绪并读写。这样系统中如果有很多并不需要读写但是就绪的文件描述符，每次都要返回。降低了效率。</li><li>边缘触发：如果一次没有执行完，直到下次IO可读写事件发生前都不会再有通知，也就是只要0变1的上升沿才会触发，丢失了剩余的数据。在发生文件描述符就绪时，采用非阻塞的方式尽可能多的进行IO。</li></ul></li></ul><ul><li><p>高并发场景下，对消息的读取和分割可能和epoll_wait在不同的线程中，这时候如果选择LT，那么在读完数据前，epoll_wait会不停的无谓醒来。</p></li><li><p>饥饿现象：</p></li><li><ul><li>在边缘触发条件下，存在某个就绪的文件描述符上有大量的输入，会出现饥饿现象</li></ul></li></ul><h4 id="用epoll实现定时器"><a href="#用epoll实现定时器" class="headerlink" title="用epoll实现定时器"></a>用epoll实现定时器</h4><h4 id="用epoll处理signal"><a href="#用epoll处理signal" class="headerlink" title="用epoll处理signal"></a>用epoll处理signal</h4><p>将signal转换为对一个文件描述符的读写，初始化一个管道，一端read，一端write，其中read添加到epoll中，这样当信号来的时候，将信号写入wirte端，read端的文件描述符上的read事件被触发，epoll_wait就返回了</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2020/07/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/07/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ul><li><p>进程是操作系统分配资源的最小单位，是程序的实体，操作系统运行一个程序，那这个程序就是一个进程，每个进程有自己的pid进程号。操作系统会为进程分配一块内存。</p></li><li><p>而线程包含在进程之中，一个进程可以并发多个线程，但这里的并发是在cpu时间片上的串行执行，同一个进程中的线程共享进程包括内存的所有资源，而每个线程只需要分配自己的一个程序计数器，栈，寄存器这些东西。在线程上的切换是由内核根据这些完成的。</p></li><li><p>在进程中可以创建fork一个子进程，调用系统的clone操作，在内核中创建出一个task对象，并返回子进程号，区别在于是否拷贝内存，当然拷贝的话现在的操作系统也是拷贝索引。</p></li><li><p>进程控制块PCB（数据结构）</p></li><li><ul><li><p>pid</p></li><li><p>user</p></li><li><p>ppid</p></li><li><p>状态保存区，栈，pc，寄存器</p></li><li><p>控制信息</p></li><li><ul><li>状态</li><li>通信信息</li><li>所用资源</li><li>进程链</li></ul></li></ul></li><li><p>进程 = 资源平台+执行线程</p></li><li><p>线程能够减少并发执行的时间和空间，比进程创建和结束的时间短，切换时间短，可直接进行不通过内核的通信</p></li><li><p>CPU对进程的管理</p></li><li><p>进程状态</p></li><li><ul><li><p>创建</p></li><li><ul><li><p>为子进程分配内存fork</p></li><li><p>复制父进程内存和cpu寄存器到子进程</p></li><li><p>exec加载并执行，使得上一步对父进程的复制没有作用了</p></li><li><ul><li>可以通过vfork优化，分配内存后直接exec</li><li>cow写时复制，利用虚存管理，只复制页表，共享的读，只有写时复制双份</li></ul></li></ul></li><li><p>就绪</p></li><li><ul><li>阻塞态被唤醒进入就绪态</li><li>运行态遇到时间片调度，进入就绪态</li><li>中断产生，运行态进入就绪态</li></ul></li><li><p>运行</p></li><li><p>阻塞</p></li><li><ul><li>进程自我阻塞，select，sleep等</li></ul></li><li><p>结束（僵尸）</p></li><li><ul><li>wait父进程等待子进程结束，帮助销毁回收内核中的僵尸PCB数据</li><li>exit只能释放自己的内存，关闭文件连接，释放内存，检查父进程是否存活，清理僵尸进程</li></ul></li></ul></li><li><p>cpu调度</p></li><li><ul><li><p>从就绪队列中选择一个进程/线程，进入运行态</p></li><li><p>上下文切换</p></li><li><ul><li>切换当前cpu任务，从一个进程/线程进入下一个</li><li>保存当前pcb/tcb中的上下文cpu状态</li><li>读取下一个进程/线程的上下文</li></ul></li><li><p>原则</p></li><li><ul><li>cpu使用率，吞吐量（单位时间总完成），周转时间，等待时间，响应时间，公平</li></ul></li><li><p>策略</p></li><li><ul><li><p>FCFS先来先服务</p></li><li><p>短进程优先</p></li><li><p>最高响应比优先R = （等待+执行）/等待</p></li><li><p>轮询（定义合适的时间片，减少上下文切换开销）</p></li><li><p>多级反馈队列</p></li><li><ul><li>多级，高优先级队列先执行</li><li>各个队列内部可以选择不同的策略</li><li>反馈，任务随着运行时间动态优先级下降和上升</li></ul></li><li><p>公平共享调度，面对多用户</p></li></ul></li><li><p>优先级反转</p></li><li><ul><li>ABC优先级任务，C占用了x资源，A等待x资源即等待C的释放，但B优先级高于C，所以C需要等待B，导致A被低优先级B影响</li><li>优先级继承，或设置资源优先级</li></ul></li></ul></li><li><p>linux调度器</p></li><li><ul><li><p>O（n）</p></li><li><ul><li>就绪队列遍历问题</li><li>多核cpu扩展性问题，通过自旋锁满足多个cpu对队列的并发访问</li><li>cpu空转问题，全部进程时间片被耗尽后需要重新计算时间片</li><li>一个进程会在多个cpu上跳来跳去</li><li>实时调度性能一般</li></ul></li><li><p>O（1）</p></li><li><ul><li>每个CPU都有一个runable队列，把大锁变成小锁</li><li>优先级反馈队列</li><li>负载层</li><li>抢占式内核</li></ul></li><li><p>CFS</p></li><li><ul><li>CFS调度器的公平就是保证所有的可运行状态的进程按照权重分配其CPU资源</li><li>红黑树，虚拟时间轴</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
