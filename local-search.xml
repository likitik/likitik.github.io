<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2020/07/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/07/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ul><li><p>进程是操作系统分配资源的最小单位，是程序的实体，操作系统运行一个程序，那这个程序就是一个进程，每个进程有自己的pid进程号。操作系统会为进程分配一块内存。</p></li><li><p>而线程包含在进程之中，一个进程可以并发多个线程，但这里的并发是在cpu时间片上的串行执行，同一个进程中的线程共享进程包括内存的所有资源，而每个线程只需要分配自己的一个程序计数器，栈，寄存器这些东西。在线程上的切换是由内核根据这些完成的。</p></li><li><p>在进程中可以创建fork一个子进程，调用系统的clone操作，在内核中创建出一个task对象，并返回子进程号，区别在于是否拷贝内存，当然拷贝的话现在的操作系统也是拷贝索引。</p></li><li><p>进程控制块PCB（数据结构）</p></li><li><ul><li><p>pid</p></li><li><p>user</p></li><li><p>ppid</p></li><li><p>状态保存区，栈，pc，寄存器</p></li><li><p>控制信息</p></li><li><ul><li>状态</li><li>通信信息</li><li>所用资源</li><li>进程链</li></ul></li></ul></li><li><p>进程 = 资源平台+执行线程</p></li><li><p>线程能够减少并发执行的时间和空间，比进程创建和结束的时间短，切换时间短，可直接进行不通过内核的通信</p></li><li><p>CPU对进程的管理</p></li><li><p>进程状态</p></li><li><ul><li><p>创建</p></li><li><ul><li><p>为子进程分配内存fork</p></li><li><p>复制父进程内存和cpu寄存器到子进程</p></li><li><p>exec加载并执行，使得上一步对父进程的复制没有作用了</p></li><li><ul><li>可以通过vfork优化，分配内存后直接exec</li><li>cow写时复制，利用虚存管理，只复制页表，共享的读，只有写时复制双份</li></ul></li></ul></li><li><p>就绪</p></li><li><ul><li>阻塞态被唤醒进入就绪态</li><li>运行态遇到时间片调度，进入就绪态</li><li>中断产生，运行态进入就绪态</li></ul></li><li><p>运行</p></li><li><p>阻塞</p></li><li><ul><li>进程自我阻塞，select，sleep等</li></ul></li><li><p>结束（僵尸）</p></li><li><ul><li>wait父进程等待子进程结束，帮助销毁回收内核中的僵尸PCB数据</li><li>exit只能释放自己的内存，关闭文件连接，释放内存，检查父进程是否存活，清理僵尸进程</li></ul></li></ul></li><li><p>cpu调度</p></li><li><ul><li><p>从就绪队列中选择一个进程/线程，进入运行态</p></li><li><p>上下文切换</p></li><li><ul><li>切换当前cpu任务，从一个进程/线程进入下一个</li><li>保存当前pcb/tcb中的上下文cpu状态</li><li>读取下一个进程/线程的上下文</li></ul></li><li><p>原则</p></li><li><ul><li>cpu使用率，吞吐量（单位时间总完成），周转时间，等待时间，响应时间，公平</li></ul></li><li><p>策略</p></li><li><ul><li><p>FCFS先来先服务</p></li><li><p>短进程优先</p></li><li><p>最高响应比优先R = （等待+执行）/等待</p></li><li><p>轮询（定义合适的时间片，减少上下文切换开销）</p></li><li><p>多级反馈队列</p></li><li><ul><li>多级，高优先级队列先执行</li><li>各个队列内部可以选择不同的策略</li><li>反馈，任务随着运行时间动态优先级下降和上升</li></ul></li><li><p>公平共享调度，面对多用户</p></li></ul></li><li><p>优先级反转</p></li><li><ul><li>ABC优先级任务，C占用了x资源，A等待x资源即等待C的释放，但B优先级高于C，所以C需要等待B，导致A被低优先级B影响</li><li>优先级继承，或设置资源优先级</li></ul></li></ul></li><li><p>linux调度器</p></li><li><ul><li><p>O（n）</p></li><li><ul><li>就绪队列遍历问题</li><li>多核cpu扩展性问题，通过自旋锁满足多个cpu对队列的并发访问</li><li>cpu空转问题，全部进程时间片被耗尽后需要重新计算时间片</li><li>一个进程会在多个cpu上跳来跳去</li><li>实时调度性能一般</li></ul></li><li><p>O（1）</p></li><li><ul><li>每个CPU都有一个runable队列，把大锁变成小锁</li><li>优先级反馈队列</li><li>负载层</li><li>抢占式内核</li></ul></li><li><p>CFS</p></li><li><ul><li>CFS调度器的公平就是保证所有的可运行状态的进程按照权重分配其CPU资源</li><li>红黑树，虚拟时间轴</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
